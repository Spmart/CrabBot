package org.spmart.tphcrabbot.util;

import java.io.*;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;

/**
 * DNS request that can be built from dns server and domain.
 */
public class DNSRequest {

    private static final int DNS_SERVER_PORT = 53;
    private String dnsServerHostname;
    private String domainName;

    /**
     * Create a DNS request object with custom DNS server and domain name information
     * about which you need.
     * @param dnsServerHostname DNS server. Can be a domain or IP.
     * @param domainName Domain, that need to be checked.
     */
    public DNSRequest(String dnsServerHostname, String domainName) {
        this.dnsServerHostname = dnsServerHostname;
        this.domainName = domainName;
    }

    /**
     * Create a DNS request object with 8.8.8.8 DNS server and domain name information
     * about which you need.
     * @param domainName Domain, that need to be checked.
     */
    public DNSRequest(String domainName) {
        this.dnsServerHostname = "8.8.8.8";
        this.domainName = domainName;
    }

    /**
     * Returns list of IP for domain. Uses InetAddress to find domain IP. You can't specify DNS server here.
     * Uses system DNS settings.
     * @param host Hostname, which IP is needed.
     * @return List of IP-addresses.
     */
    @Deprecated
    private ArrayList<String> getIP(String host) {
        ArrayList<String> ipList = new ArrayList<>();
        try {
            InetAddress[] inetAddresses = InetAddress.getAllByName(host);
            for (InetAddress ip : inetAddresses) {
                ipList.add(ip.getHostAddress());
            }
        } catch (UnknownHostException uhe) {
            if (ipList.isEmpty()) {
                ipList.add("Unknown host");
            }
        }
        return ipList;
    }

    /**
     * Send DNS request.
     * @return DNSResponse object with domain name, dns server hostname, domain IP and PTR.
     */
    public DNSResponse send() {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        DataOutputStream dos = new DataOutputStream(baos);

        Logger logger = Logger.INSTANCE;

        /*
         *** Build a DNS Request Frame ****
         https://stackoverflow.com/questions/36743226/java-send-udp-packet-to-dns-server
         Identifier: A 16-bit identification field generated by the device that creates the DNS query.
         It is copied by the server into the response, so it can be used by that device to match that
         query to the corresponding reply received from a DNS server. This is used in a manner similar
         to how the Identifier field is used in many of the ICMP message types.
        */
        try {
            dos.writeShort(0x1234);
            // Write Query Flags
            dos.writeShort(0x0100);
            // Question Count: Specifies the number of questions in the Question section of the message.
            dos.writeShort(0x0001);
            // Answer Record Count: Specifies the number of resource records in the Answer section of the message.
            dos.writeShort(0x0000);
            // Authority Record Count: Specifies the number of resource records in the Authority section of
            // the message. (“NS” stands for “name server”)
            dos.writeShort(0x0000);
            // Additional Record Count: Specifies the number of resource records in the Additional section of the message.
            dos.writeShort(0x0000);

            String[] domainParts = domainName.split("\\.");

            for (int i = 0; i < domainParts.length; i++) {
                byte[] domainBytes = domainParts[i].getBytes("UTF-8");
                dos.writeByte(domainBytes.length);
                dos.write(domainBytes);
            }

            // No more parts
            dos.writeByte(0x00);
            // Type 0x01 = A (Host Request)
            dos.writeShort(0x0001);
            // Class 0x01 = IN
            dos.writeShort(0x0001);
        } catch (IOException e) {
            logger.write(String.format("An error occurs while building DNS frame: %s\n", e.getMessage()));
            return new DNSResponse(domainName);
        }

        byte[] dnsFrame = baos.toByteArray();
        String domainNameIp = "Not found :(";

        // *** Send DNS Request Frame ***
        try {
            DatagramSocket socket = new DatagramSocket();
            //String DNSServerIP = getIP(dnsServerHostname);
            DatagramPacket dnsReqPacket = new DatagramPacket(dnsFrame, dnsFrame.length,
                    InetAddress.getByName(dnsServerHostname), DNS_SERVER_PORT);
            socket.send(dnsReqPacket);

            // Await response from DNS server
            byte[] buf = new byte[1024];
            DatagramPacket packet = new DatagramPacket(buf, buf.length);

            socket.receive(packet);

            ArrayList<String> serviceInfo = new ArrayList<>();
            DataInputStream din = new DataInputStream(new ByteArrayInputStream(buf));

            /*
            Add: Transaction ID, Flags, Questions, Answers RRs, Authority RRs, Additional RRs
             */
            for (int i = 0; i < 6; i++) {
                serviceInfo.add(String.format("%x", din.readShort()));
            }

            int recLen = 0;
            while ((recLen = din.readByte()) > 0) {
                byte[] record = new byte[recLen];

                for (int i = 0; i < recLen; i++) {
                    record[i] = din.readByte();
                }
                serviceInfo.add(String.format("Record: %s", new String(record, StandardCharsets.UTF_8)));
            }

            //Add Record Type, Class, Field, Type, Class, TTL
            for (int i = 0; i < 5; i++) {
                serviceInfo.add(String.format("%x", din.readShort()));
            }
            serviceInfo.add(String.format("TTL: 0x%x", din.readInt()));

            short addrLen = din.readShort();
            serviceInfo.add(String.format("Len: 0x%x", addrLen));

            domainNameIp = "";
            for (int i = 0; i < addrLen; i++ ) {
                domainNameIp += (String.format("%d", (din.readByte() & 0xFF)));
                if (addrLen - i > 1) { // dot in the end of ip is not needed
                    domainNameIp += ".";
                }
            }
        } catch (IOException e) {
            logger.write(String.format("An error occurs while working with sockets: %s\n", e.getMessage()));
            return new DNSResponse(domainName);
        }

        if (domainNameIp.isEmpty()) {
            return new DNSResponse(domainName, dnsServerHostname, domainNameIp);
        } else {
            return new DNSResponse(domainName, dnsServerHostname, domainNameIp, getPtr(domainNameIp));
        }
    }


    /**
     * Send RDNS query and get PTR for IP.
     * @param ip IP address splited by dots like that 194.53.112.31
     * @return PTR record.
     */
    //This temp realization is here from Stackoverflow. It's ugly, but it works
    private static String getPtr(final String ip) {
        String ptr = "";
        final String[] bytes = ip.split("\\.");
        Logger logger = Logger.INSTANCE;

        if (bytes.length == 4)
        {
            try
            {
                final java.util.Hashtable<String, String> env = new java.util.Hashtable<String, String>();
                env.put("java.naming.factory.initial", "com.sun.jndi.dns.DnsContextFactory");
                final javax.naming.directory.DirContext ctx = new javax.naming.directory.InitialDirContext(env);
                final String reverseDnsDomain = bytes[3] + "." + bytes[2] + "." + bytes[1] + "." + bytes[0] + ".in-addr.arpa";
                final javax.naming.directory.Attributes attrs = ctx.getAttributes(reverseDnsDomain, new String[]
                        {
                                "PTR",
                        });
                for (final javax.naming.NamingEnumeration<? extends javax.naming.directory.Attribute> ae = attrs.getAll(); ae.hasMoreElements();)
                {
                    final javax.naming.directory.Attribute attr = ae.next();
                    final String attrId = attr.getID();
                    for (final java.util.Enumeration<?> vals = attr.getAll(); vals.hasMoreElements();)
                    {
                        String value = vals.nextElement().toString();

                        if ("PTR".equals(attrId))
                        {
                            final int len = value.length();
                            if (value.charAt(len - 1) == '.')
                            {
                                // Strip out trailing period
                                value = value.substring(0, len - 1);
                            }
                            ptr = value;
                        }
                    }
                }
                ctx.close();
            }
            catch (final javax.naming.NamingException e)
            {
                logger.write(String.format("No reverse DNS or an error occurred: %s\n", e.getMessage()));
            }
        }

        if (ptr.isEmpty())
        {
            try
            {
                ptr = java.net.InetAddress.getByName(ip).getCanonicalHostName();
            }
            catch (final java.net.UnknownHostException e1)
            {
                ptr = ip;
            }
        }
        return ptr;
    }
}
