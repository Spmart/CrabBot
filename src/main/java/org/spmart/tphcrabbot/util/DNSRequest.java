package org.spmart.tphcrabbot.util;

import java.io.*;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.ArrayList;

public class DNSRequest {
    private static final int DNS_SERVER_PORT = 53;
    private String dnsServerHostname;
    private String domainName;


    public DNSRequest(String dnsServerHostname, String domainName) {
        this.dnsServerHostname = dnsServerHostname;
        this.domainName = domainName;
    }

    public DNSRequest(String domainName) {
        this.dnsServerHostname = "8.8.8.8";
        this.domainName = domainName;
    }

    @Deprecated
    private String getIP(String host) {
        try {
            InetAddress[] IPList = InetAddress.getAllByName(host);
            //for (int i = 0; i < IP.length; i++) {
            //    System.out.println("IPv4 : " + IP[i].getHostAddress());
            //}
            return IPList[0].getHostAddress();
        } catch (UnknownHostException uhe) {
            return "Unknown Host!";
        }
    }

    public DNSResponse send() {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        DataOutputStream dos = new DataOutputStream(baos);

        /*
         *** Build a DNS Request Frame ****
         https://stackoverflow.com/questions/36743226/java-send-udp-packet-to-dns-server
         Identifier: A 16-bit identification field generated by the device that creates the DNS query.
         It is copied by the server into the response, so it can be used by that device to match that
         query to the corresponding reply received from a DNS server. This is used in a manner similar
         to how the Identifier field is used in many of the ICMP message types.
        */
        try {
            dos.writeShort(0x1234);
            // Write Query Flags
            dos.writeShort(0x0100);
            // Question Count: Specifies the number of questions in the Question section of the message.
            dos.writeShort(0x0001);
            // Answer Record Count: Specifies the number of resource records in the Answer section of the message.
            dos.writeShort(0x0000);
            // Authority Record Count: Specifies the number of resource records in the Authority section of
            // the message. (“NS” stands for “name server”)
            dos.writeShort(0x0000);
            // Additional Record Count: Specifies the number of resource records in the Additional section of the message.
            dos.writeShort(0x0000);

            String[] domainParts = domainName.split("\\.");

            for (int i = 0; i < domainParts.length; i++) {
                byte[] domainBytes = domainParts[i].getBytes("UTF-8");
                dos.writeByte(domainBytes.length);
                dos.write(domainBytes);
            }

            // No more parts
            dos.writeByte(0x00);
            // Type 0x01 = A (Host Request)
            dos.writeShort(0x0001);
            // Class 0x01 = IN
            dos.writeShort(0x0001);
        } catch (IOException e) {
            return new DNSResponse(domainName);
        }

        byte[] dnsFrame = baos.toByteArray();
        String domainNameIp = "Not found :(";

        // *** Send DNS Request Frame ***
        try {
            DatagramSocket socket = new DatagramSocket();
            //String DNSServerIP = getIP(dnsServerHostname);
            DatagramPacket dnsReqPacket = new DatagramPacket(dnsFrame, dnsFrame.length,
                    InetAddress.getByName(dnsServerHostname), DNS_SERVER_PORT);
            socket.send(dnsReqPacket);

            // Await response from DNS server
            byte[] buf = new byte[1024];
            DatagramPacket packet = new DatagramPacket(buf, buf.length);

            socket.receive(packet);

            ArrayList<String> serviceInfo = new ArrayList<>();
            DataInputStream din = new DataInputStream(new ByteArrayInputStream(buf));

            /*
            Add: Transaction ID, Flags, Questions, Answers RRs, Authority RRs, Additional RRs
             */
            for (int i = 0; i < 6; i++) {
                serviceInfo.add(String.format("%x", din.readShort()));
            }

            int recLen = 0;
            while ((recLen = din.readByte()) > 0) {
                byte[] record = new byte[recLen];

                for (int i = 0; i < recLen; i++) {
                    record[i] = din.readByte();
                }
                serviceInfo.add("Record: " + new String(record, "UTF-8"));
            }

            //Add Record Type, Class, Field, Type, Class, TTL
            for (int i = 0; i < 5; i++) {
                serviceInfo.add(String.format("%x", din.readShort()));
            }
            serviceInfo.add("TTL: 0x" + String.format("%x", din.readInt()));

            short addrLen = din.readShort();
            serviceInfo.add("Len: 0x" + String.format("%x", addrLen));

            domainNameIp = "";
            for (int i = 0; i < addrLen; i++ ) {
                domainNameIp += ("" + String.format("%d", (din.readByte() & 0xFF)));
                if (addrLen - i > 1) { // dot in the end of ip is not needed
                    domainNameIp += ".";
                }
            }
        } catch (IOException e) {
            return new DNSResponse(domainName);
        }

        if (domainNameIp.isEmpty()) {
            return new DNSResponse(domainName, dnsServerHostname, domainNameIp);
        } else {
            return new DNSResponse(domainName, dnsServerHostname, domainNameIp, getPtr(domainNameIp));
        }
    }


    //This temp realization is here from Stackoverflow. It's ugly, but it works
    //Not quite well. With lib telegrambots its generate strange exception, that processing by lib silently
    private static String getPtr(final String ip) {
        String ptr = "";
        final String[] bytes = ip.split("\\.");
        if (bytes.length == 4)
        {
            try
            {
                final java.util.Hashtable<String, String> env = new java.util.Hashtable<String, String>();
                env.put("java.naming.factory.initial", "com.sun.jndi.dns.DnsContextFactory");
                final javax.naming.directory.DirContext ctx = new javax.naming.directory.InitialDirContext(env);
                final String reverseDnsDomain = bytes[3] + "." + bytes[2] + "." + bytes[1] + "." + bytes[0] + ".in-addr.arpa";
                final javax.naming.directory.Attributes attrs = ctx.getAttributes(reverseDnsDomain, new String[]
                        {
                                "PTR",
                        });
                for (final javax.naming.NamingEnumeration<? extends javax.naming.directory.Attribute> ae = attrs.getAll(); ae.hasMoreElements();)
                {
                    final javax.naming.directory.Attribute attr = ae.next();
                    final String attrId = attr.getID();
                    for (final java.util.Enumeration<?> vals = attr.getAll(); vals.hasMoreElements();)
                    {
                        String value = vals.nextElement().toString();

                        if ("PTR".equals(attrId))
                        {
                            final int len = value.length();
                            if (value.charAt(len - 1) == '.')
                            {
                                // Strip out trailing period
                                value = value.substring(0, len - 1);
                            }
                            ptr = value;
                        }
                    }
                }
                ctx.close();
            }
            catch (final javax.naming.NamingException e)
            {
                // No reverse DNS that we could find, try with InetAddress
                System.out.println("Some shit");
            }
        }

        if (ptr == null || ptr.isEmpty())
        {
            try
            {
                ptr = java.net.InetAddress.getByName(ip).getCanonicalHostName();
            }
            catch (final java.net.UnknownHostException e1)
            {
                ptr = ip;
            }
        }
        return ptr;
    }
}
